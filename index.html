<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEFQON 1 Companion - Avec Firestore</title>
    <!-- Chargement de Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Importation de la police Inter */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000; /* Noir profond pour le fond (Defqon style) */
            color: #ffffff; /* Texte blanc */
        }
        /* Styles pour les boutons d'onglets */
        .tab-button {
            @apply px-4 py-2 rounded-md transition-all duration-300 ease-in-out transform; /* Ajout de transform pour les animations */
        }
        .tab-button.active {
            /* Changement: fond transparent, bordure inférieure rouge subtile, texte rougeoyant */
            @apply bg-transparent text-red-400 scale-105; /* Texte plus clair pour la lueur */
            border: none; /* Pas de bordure pleine */
            border-bottom: 2px solid #dc2626; /* Bordure inférieure rouge */
            box-shadow: none; /* Pas d'ombre de boîte pour éviter l'effet rectangulaire */
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); /* Lueur sur le texte */
        }
        .tab-button:not(.active) {
            @apply bg-gray-800 text-gray-300 hover:bg-gray-700 hover:scale-105 active:scale-95; /* Gris foncé, survol et clic */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Ombre par défaut */
        }
        .tab-button:not(.active):hover {
            box-shadow: 0 0 20px rgba(220, 38, 38, 0.7); /* Ombre rouge plus intense au survol */
        }

        /* Styles pour les champs de saisie */
        .input-field {
            /* Utilisation d'un gris un peu plus clair pour un meilleur contraste */
            @apply w-full p-3 rounded-md bg-gray-700 border border-gray-600 focus:ring-2 focus:ring-red-500 focus:border-transparent transition-all;
            color: #333333 !important; /* Rendre le texte tapé explicitement gris foncé (presque noir) et prioritaire */
        }
        .input-field::placeholder { /* Couleur pour le texte de substitution */
            color: #a0aec0 !important; /* Un gris plus clair pour les placeholders et prioritaire */
            opacity: 1; /* Assure que le placeholder n'est pas transparent */
        }
        /* Styles pour les boutons principaux (submit) */
        .btn-primary {
            @apply px-6 py-3 rounded-md bg-red-700 text-white font-semibold transition-all shadow-md transform hover:scale-105 active:scale-95; /* Rouge vif, survol et clic */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Ombre par défaut */
        }
        .btn-primary:hover {
            box-shadow: 0 0 25px rgba(220, 38, 38, 0.8); /* Ombre rouge au survol */
        }

        /* Styles pour les cartes de contenu */
        .card {
            @apply bg-gray-900 p-4 rounded-lg shadow-lg mb-4; /* Gris très foncé pour les cartes */
        }
        /* Styles pour les zones de contenu défilantes */
        .scrollable-content {
            max-height: 70vh; /* Hauteur maximale pour le défilement */
            overflow-y: auto; /* Permet le défilement vertical */
            scrollbar-width: thin; /* Style de la barre de défilement pour Firefox */
            scrollbar-color: #880808 #333333; /* Couleurs de la barre de défilement pour Firefox (Rouge/Noir) */
        }
        /* Styles de la barre de défilement pour Webkit (Chrome, Safari) */
        .scrollable-content::-webkit-scrollbar {
            width: 8px;
        }
        .scrollable-content::-webkit-scrollbar-track {
            background: #333333; /* Noir/Gris pour le fond de la barre */
            border-radius: 10px;
        }
        .scrollable-content::-webkit-scrollbar-thumb {
            background-color: #880808; /* Rouge pour le curseur de la barre */
            border-radius: 10px;
            border: 2px solid #333333;
        }
        /* Styles pour la boîte de message personnalisée */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #222; /* Gris foncé */
            color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none; /* Caché par défaut */
        }
        .message-box button {
            background-color: #dc2626; /* Rouge */
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }

        /* Styles pour les jauges circulaires (REVISITÉES) */
        .gauge-item-wrapper {
            display: flex;
            flex-direction: column; /* Organise en colonne: jauge puis nom */
            align-items: center;
            min-width: 150px; /* Assure un espace minimum pour chaque jauge */
            height: 200px; /* Hauteur de la zone pour la jauge et le nom */
            justify-content: center; /* Centrer la jauge verticalement */
            position: relative; /* Pour positionner correctement le SVG et les textes */
        }
        .gauge-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: visible; /* Assure que le stroke ne soit pas coupé */
        }
        .gauge-bg {
            stroke: #333333; /* Couleur de fond de la jauge */
            stroke-width: 15;
            fill: none;
        }
        .gauge-progress {
            stroke: #dc2626; /* Rouge Defqon pour la progression */
            stroke-width: 15;
            fill: none;
            transition: stroke-dasharray 0.5s ease-in-out; /* Animation fluide */
            stroke-linecap: round; /* Rendre les extrémités de la barre arrondies */
            filter: drop-shadow(0 0 5px rgba(220, 38, 38, 0.7)); /* Ombre pour la lueur */
            transform: rotate(-90deg); /* Rotation pour démarrer en haut */
            transform-origin: 50% 50%; /* Point de pivot pour la rotation */
        }
        .gauge-text-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 2.5rem; /* Taille plus grande pour le nombre */
            font-weight: bold;
            text-align: center;
            z-index: 1; /* Assure que le texte est au-dessus du SVG */
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); /* Lueur sur le texte */
        }
        .gauge-label-overlay {
            position: absolute;
            top: 75%; /* Positionnement de l'étiquette sous le nombre */
            left: 50%;
            transform: translate(-50%, -50%);
            color: #a0aec0; /* Gris clair */
            font-size: 1rem; /* Taille de police légèrement plus grande */
            text-align: center;
            z-index: 1; /* Assure que le texte est au-dessus du SVG */
        }


        /* Style pour le timer */
        @keyframes subtle-glow {
            0% { box-shadow: 0 0 15px rgba(220, 38, 38, 0.6), inset 0 0 8px rgba(220, 38, 38, 0.3); border-color: #dc2626; }
            50% { box-shadow: 0 0 40px rgba(220, 38, 38, 1), inset 0 0 15px rgba(220, 38, 38, 0.5); border-color: #ef4444; }
            100% { box-shadow: 0 0 15px rgba(220, 38, 38, 0.6), inset 0 0 8px rgba(220, 38, 38, 0.3); border-color: #dc2626; }
        }
        .countdown-box {
            @apply bg-gray-900 border-2 border-red-700 p-4 rounded-xl text-center mb-8 flex items-center justify-center;
            animation: subtle-glow 2.5s infinite alternate;
            width: 90%;
            max-width: 400px;
            height: 90px;
            overflow: hidden;
        }
        .countdown-box .countdown-text {
            /* Utilisation d'une taille de police ajustée pour remplir l'espace sans déborder */
            font-size: 1.4rem; /* Taille de base ajustée */
            @apply text-white font-bold;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.9), 0 0 30px rgba(255, 0, 0, 0.7);
            white-space: nowrap; /* Empêche le retour à la ligne */
            overflow: hidden; /* Cache le texte qui dépasse */
            text-overflow: ellipsis; /* Ajoute des points de suspension si le texte est trop long */
            
            /* Flexbox pour le centrage parfait */
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%; /* S'assurer que le texte prend toute la hauteur disponible pour le centrage */
            width: 100%; /* S'assurer que le texte prend toute la largeur disponible */
        }
        /* Ajustements responsifs pour la taille de la police du minuteur */
        @media (min-width: 640px) { /* sm */
            .countdown-box .countdown-text {
                font-size: 1.8rem;
            }
        }
        @media (min-width: 768px) { /* md */
            .countdown-box .countdown-text {
                font-size: 2.2rem;
            }
        }
        @media (min-width: 1024px) { /* lg */
            .countdown-box .countdown-text {
                font-size: 2.6rem;
            }
        }

        .countdown-box .countdown-label {
            display: none;
        }
        .countdown-box .countdown-label.visible {
            display: block;
            @apply text-red-400 text-base sm:text-lg font-semibold mt-1;
        }

    </style>
</head>
<body class="min-h-screen p-4 sm:p-6 lg:p-8 flex flex-col items-center">
    <h1 class="text-4xl sm:text-5xl font-bold text-center mb-8 text-red-500">DEFQON 1 Companion</h1>

    <!-- Conteneur des onglets et du bouton de connexion -->
    <div class="flex flex-col sm:flex-row items-center justify-center mb-8 gap-4">
        <!-- Onglets de navigation -->
        <div class="flex space-x-2 sm:space-x-4 p-1 bg-gray-800 rounded-lg shadow-inner">
            <button id="tabAccueil" class="tab-button" onclick="setActiveTab('accueil')">
                Accueil
            </button>
            <button id="tabSeRetrouver" class="tab-button" onclick="setActiveTab('seRetrouver')">
                Se retrouver
            </button>
            <button id="tabObjectifs" class="tab-button" onclick="setActiveTab('objectifs')">
                Objectifs
            </button>
        </div>
        <!-- Bouton "Se connecter" séparé -->
        <button id="tabConnect" class="px-4 py-2 rounded-md bg-red-700 text-white font-semibold transition-all shadow-lg hover:bg-red-800 hover:scale-105 active:scale-95 transform" onclick="setActiveTab('connect')">
            Se connecter
        </button>
    </div>

    <!-- Contenu des onglets -->
    <div id="tabContent" class="w-full max-w-2xl bg-gray-900 p-6 rounded-xl shadow-2xl">
        <!-- Le contenu des onglets sera injecté ici par JavaScript -->
    </div>

    <!-- Message Box (remplace alert() et confirm()) -->
    <div id="messageBox" class="message-box">
        <p id="messageBoxContent"></p>
        <button onclick="hideMessageBox()">OK</button>
    </div>

    <!-- Script Firebase SDKs -->
    <script type="module">
        // Importation des modules Firebase nécessaires via CDN
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, addDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL CONSTANTS AND INITIALIZATION ---
        // Global variables __app_id, __firebase_config and __initial_auth_token
        // are provided by the Canvas environment.
        // We use default values in case they are not defined (e.g., for local testing).
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-defqon-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let firebaseConfig = {};
        // Vérifie si __firebase_config est défini (utilisé par Canvas)
        if (typeof __firebase_config !== 'undefined' && __firebase_config) {
            try {
                firebaseConfig = JSON.parse(__firebase_config);
            } catch (e) {
                console.error("Erreur lors de l'analyse de __firebase_config:", e);
                // Fallback à une configuration vide si l'analyse échoue
            }
        } else {
            // Si __firebase_config n'est pas défini (par exemple, sur GitHub),
            // l'utilisateur DOIT remplir cette configuration manuellement.
            console.warn("Attention: __firebase_config n'est pas défini. Si vous exécutez cette application en dehors de l'environnement Canvas, veuillez remplacer 'YOUR_FIREBASE_CONFIG_HERE' par votre configuration Firebase réelle.");
            firebaseConfig = {
                apiKey: "YOUR_FIREBASE_API_KEY",
                authDomain: "YOUR_FIREBASE_AUTH_DOMAIN",
                projectId: "YOUR_FIREBASE_PROJECT_ID",
                storageBucket: "YOUR_FIREBASE_STORAGE_BUCKET",
                messagingSenderId: "YOUR_FIREBASE_MESSAGING_SENDER_ID",
                appId: "YOUR_FIREBASE_APP_ID",
                // measurementId: "YOUR_FIREBASE_MEASUREMENT_ID" // Optionnel, si vous utilisez Google Analytics
                };
        }

        let currentUserId = null;
        let firebaseApp;
        let db;
        let auth;
        let isAuthReady = false; // Indicates if authentication is ready

        // Constants for Defqon 1 countdown
        const DEFQON_START_DATE = new Date('2025-06-26T12:00:00'); // June 26, 2025, 12:00 PM
        const DEFQON_END_DATE = new Date('2025-06-29T23:59:59'); // June 29, 2025, 11:59 PM (for 4 days until Sunday evening)
        let countdownInterval = null;

        // --- UTILITY FUNCTIONS ---

        // Function to generate a UUID (Universally Unique Identifier)
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Utility function to escape HTML and prevent XSS
        function escapeHTML(str) {
            const div = document.createElement('div');
            div.appendChild(document.createTextNode(str));
            return div.innerHTML;
        }

        // --- CUSTOM ALERT MESSAGE BOX HANDLING ---
        // Expose the function to the global scope so it can be called from HTML
        window.showMessageBox = function(message) {
            const msgBox = document.getElementById('messageBox');
            const msgContent = document.getElementById('messageBoxContent');
            msgContent.textContent = message;
            msgBox.style.display = 'block';
        }

        // Expose the function to the global scope
        window.hideMessageBox = function() {
            document.getElementById('messageBox').style.display = 'none';
        }

        // --- FIREBASE INITIALIZATION ---
        try {
            firebaseApp = initializeApp(firebaseConfig);
            db = getFirestore(firebaseApp);
            auth = getAuth(firebaseApp);

            // Manage authentication state
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentUserId = user.uid;
                } else {
                    // If no user is logged in, try to sign in anonymously
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                        // Ensure there's a userId after authentication
                        currentUserId = auth.currentUser?.uid || generateUUID();
                    } catch (error) {
                        console.error("Erreur lors de la connexion anonyme ou avec jeton personnalisé:", error);
                        showMessageBox("Erreur de connexion : " + error.message);
                        currentUserId = generateUUID(); // Fallback to a random ID if auth fails
                    }
                }
                isAuthReady = true; // Mark authentication as ready
                // Once authentication is ready, we can start listening to data
                setupFirestoreListeners();
                // Display the default tab ('Accueil') once authentication and listeners are ready
                window.setActiveTab('accueil');
                startCountdown(); // Start the countdown globally
            });

        } catch (error) {
            console.error("Erreur lors de l'initialisation de Firebase:", error);
            showMessageBox("Erreur critique: Impossible d'initialiser l'application. Vérifiez la configuration Firebase.");
            // Prevent the app from crashing if Firebase is not configured
            db = null;
            auth = null;
            isAuthReady = true; // Mark as ready even without Firebase to avoid total blocking
            window.setActiveTab('accueil'); // Still attempt to show 'Accueil'
        }


        // --- FIRESTORE OPERATIONS ---

        let locationMessages = []; // Local array to store location messages
        let challenges = []; // Local array to store challenges (now called objectifs)
        let userProfiles = {}; // Stores user profiles
        let onlineUsersCount = 0; // Counter for online users

        // Set up Firestore listeners once authentication is ready
        function setupFirestoreListeners() {
            if (!db || !isAuthReady) return; // Ensure Firebase is initialized and auth is ready

            // Listener for location messages
            const locationsColRef = collection(db, `artifacts/${appId}/public/data/locations`);
            onSnapshot(locationsColRef, (snapshot) => {
                const fetchedLocations = [];
                snapshot.forEach(doc => {
                    // Firestore stores document IDs, and we want to include them
                    fetchedLocations.push({ id: doc.id, ...doc.data() });
                });
                // Sort by timestamp to display the most recent first
                fetchedLocations.sort((a, b) => b.timestamp - a.timestamp);
                locationMessages = fetchedLocations; // Update local array
                updateLocationMessagesDisplay(); // Update display
            }, (error) => {
                console.error("Erreur lors de l'écoute des messages de localisation:", error);
                showMessageBox("Impossible de charger les messages de localisation en temps réel.");
            });

            // Listener for challenges (now objectifs)
            const challengesColRef = collection(db, `artifacts/${appId}/public/data/challenges`); // Collection name remains 'challenges' in Firestore
            onSnapshot(challengesColRef, (snapshot) => {
                const fetchedChallenges = [];
                snapshot.forEach(doc => {
                    fetchedChallenges.push({ id: doc.id, ...doc.data() });
                });
                challenges = fetchedChallenges; // Update local array
                updateChallengesDisplay(); // Update display for objectifs
                updateChallengeGauges(); // Update gauges for objectifs
            }, (error) => {
                console.error("Erreur lors de l'écoute des objectifs:", error);
                showMessageBox("Impossible de charger les objectifs en temps réel.");
            });

            // Listener for user profiles and online presence
            const profilesColRef = collection(db, `artifacts/${appId}/public/data/profiles`);
            onSnapshot(profilesColRef, (snapshot) => {
                const fetchedProfiles = {};
                let count = 0;
                const now = Date.now();
                const onlineThreshold = now - 60000; // 60 seconds to be considered "online"

                snapshot.forEach(doc => {
                    const profile = { id: doc.id, ...doc.data() };
                    fetchedProfiles[doc.id] = profile;
                    if (profile.lastOnline && profile.lastOnline > onlineThreshold) {
                        count++;
                    }
                });
                userProfiles = fetchedProfiles; // Update profile cache
                onlineUsersCount = count; // Update counter
                updateOnlineUsersCountDisplay(); // Update counter display
                updateChallengeGauges(); // Update challenge gauges (for usernames)
            }, (error) => {
                console.error("Erreur lors de l'écoute des profils utilisateurs:", error);
                showMessageBox("Impossible de charger les profils utilisateurs.");
            });

            // Periodic update of the current user's "lastOnline" status
            setInterval(async () => {
                if (db && currentUserId && isAuthReady) {
                    try {
                        const userProfileRef = doc(db, `artifacts/${appId}/public/data/profiles`, currentUserId);
                        await setDoc(userProfileRef, { lastOnline: Date.now() }, { merge: true }); // Only update lastOnline
                    } catch (error) {
                        console.error("Erreur lors de la mise à jour du statut en ligne:", error);
                    }
                }
            }, 30000); // Update every 30 seconds
        }

        // Function to send the location message to Firestore
        window.sendLocationMessageEvent = async function() {
            if (!db || !currentUserId) {
                showMessageBox("L'application n'est pas prête ou l'utilisateur n'est pas authentifié.");
                return;
            }
            const inputElement = document.getElementById('locationMessageInput');
            const message = inputElement.value.trim();
            if (message === '') return;

            try {
                // Use setDoc with the user ID as document ID to store the last position
                const locationDocRef = doc(db, `artifacts/${appId}/public/data/locations`, currentUserId);
                await setDoc(locationDocRef, {
                    userId: currentUserId,
                    message: message,
                    timestamp: Date.now(),
                });
                inputElement.value = ''; // Clear the field after sending
            } catch (error) {
                console.error("Erreur lors de l'envoi du message de localisation:", error);
                showMessageBox("Erreur lors de l'envoi du message de localisation.");
            }
        }

        // Function to add a new challenge (objectif) to Firestore
        window.addChallengeEvent = async function() {
            if (!db || !currentUserId) {
                showMessageBox("L'application n'est pas prête ou l'utilisateur n'est pas authentifié.");
                return;
            }
            const inputElement = document.getElementById('newChallengeInput');
            const text = inputElement.value.trim();
            if (text === '') return;

            try {
                // addDoc adds a new document with an automatically generated ID
                await addDoc(collection(db, `artifacts/${appId}/public/data/challenges`), {
                    text: text,
                    completed: false,
                    createdBy: currentUserId,
                    createdAt: Date.now(),
                });
                inputElement.value = '';
            } catch (error) {
                console.error("Erreur lors de l'ajout de l'objectif:", error);
                showMessageBox("Erreur lors de l'ajout de l'objectif.");
            }
        }

        // Function to toggle the "completed" status of a challenge (objectif) in Firestore
        window.toggleChallengeCompletionEvent = async function(challengeId, newStatus) {
            if (!db || !currentUserId) {
                showMessageBox("L'application n'est pas prête ou l'utilisateur n'est pas authentifié.");
                return;
            }
            try {
                const challengeRef = doc(db, `artifacts/${appId}/public/data/challenges`, challengeId);
                await updateDoc(challengeRef, {
                    completed: newStatus,
                    completedBy: newStatus ? currentUserId : null, // Who completed it
                    completedAt: newStatus ? Date.now() : null, // When it was completed
                });
            } catch (error) {
                console.error("Erreur lors de la mise à jour de l'objectif:", error);
                showMessageBox("Erreur lors de la mise à jour de l'objectif.");
            }
        }

        // --- PHONE NUMBER VALIDATION AND FORMATTING ---
        // Expose the function to the global scope for the oninput event
        window.formatPhoneNumber = function(input) {
            let value = input.value.replace(/\D/g, ''); // Remove anything that is not a digit
            let formattedValue = '';
            for (let i = 0; i < value.length; i++) {
                if (i > 0 && i % 2 === 0) {
                    formattedValue += ' ';
                }
                formattedValue += value[i];
            }
            input.value = formattedValue;
            return formattedValue; // Return the formatted value for pre-filling
        }

        // Function to save user profile (first name, phone)
        window.saveProfile = async function() {
            if (!db || !currentUserId) {
                showMessageBox("L'application n'est pas prête ou l'utilisateur n'est pas authentifié.");
                return;
            }

            const firstNameInput = document.getElementById('firstNameInput');
            const phoneNumberInput = document.getElementById('phoneNumberInput');
            const firstName = firstNameInput.value.trim();
            let phoneNumber = phoneNumberInput.value.replace(/\s/g, ''); // Remove spaces for validation

            if (!firstName) {
                showMessageBox("Veuillez saisir votre prénom.");
                return;
            }
            if (!/^\d{10}$/.test(phoneNumber)) {
                showMessageBox("Le numéro de téléphone doit contenir exactement 10 chiffres (ex: 0612345678).");
                return;
            }

            try {
                const userProfileRef = doc(db, `artifacts/${appId}/public/data/profiles`, currentUserId);
                await setDoc(userProfileRef, {
                    userId: currentUserId,
                    firstName: firstName,
                    phoneNumber: phoneNumber,
                    lastOnline: Date.now() // Also update last activity
                }, { merge: true }); // Use merge to not overwrite other fields if present
                showMessageBox("Votre profil a été enregistré avec succès !");
            } catch (error) {
                console.error("Erreur lors de l'enregistrement du profil:", error);
                showMessageBox("Erreur lors de l'enregistrement de votre profil.");
            }
        }

        // --- TAB RENDERING AND DISPLAY UPDATES ---

        // Render the content of the "Accueil" tab
        function renderAccueilTab() {
            document.getElementById('tabContent').innerHTML = `
                <div class="flex flex-col items-center justify-center p-4"> <!-- Conteneur centré pour l'onglet Accueil -->
                    <h2 class="text-3xl font-semibold mb-6 text-center text-red-400">Bienvenue à Defqon 1 !</h2>
                    
                    <div class="mb-6 mx-auto"> <!-- Centrer le compteur d'utilisateurs en ligne -->
                        <span id="onlineUsersCount" class="px-3 py-1 rounded-full bg-red-500 text-white text-sm font-semibold">
                            En ligne: 0
                        </span>
                    </div>

                    <!-- Compte à rebours du festival -->
                    <div id="countdownDisplay" class="countdown-box mx-auto"> <!-- Utilise mx-auto pour centrer le bloc -->
                        <div class="countdown-text">Chargement...</div>
                        <!-- Le label sera vide si le compte à rebours est actif -->
                        <div class="countdown-label"></div>
                    </div>
                </div>
            `;
            updateOnlineUsersCountDisplay(); // Update display for online users
            updateCountdown(); // Update countdown display
        }

        // Render the content of the "Se retrouver" tab
        function renderSeRetrouverTab() {
            document.getElementById('tabContent').innerHTML = `
                <div>
                    <h2 class="text-3xl font-semibold mb-6 text-center text-red-400">Où nous retrouver ?</h2>
                    <div class="flex flex-col sm:flex-row gap-3 mb-6">
                        <input
                            type="text"
                            id="locationMessageInput"
                            placeholder="Votre message de localisation (ex: 'Devant la scène rouge')"
                            class="input-field flex-grow"
                        />
                        <button onclick="sendLocationMessageEvent()" class="btn-primary">
                            Envoyer
                        </button>
                    </div>
                    <div id="sharedLocationsList" class="scrollable-content">
                        <!-- Les messages seront injectés ici -->
                    </div>
                </div>
            `;
            updateLocationMessagesDisplay(); // Update initial display
        }

        // Mettre à jour l'affichage des messages de localisation
        function updateLocationMessagesDisplay() {
            const listElement = document.getElementById('sharedLocationsList');
            if (!listElement) return;

            if (locationMessages.length === 0) {
                listElement.innerHTML = `<p class="text-center text-gray-400 italic">Aucun message de localisation pour l'instant. Partagez le vôtre !</p>`;
            } else {
                listElement.innerHTML = locationMessages.map(loc => {
                    const profile = userProfiles[loc.userId];
                    const senderName = profile && profile.firstName ? escapeHTML(profile.firstName) : (loc.userId ? loc.userId.substring(0, 8) + '...' : 'Inconnu');
                    return `
                    <div class="card flex items-center justify-between">
                        <div>
                            <p class="text-lg font-medium text-white">${escapeHTML(loc.message)}</p>
                            <p class="text-sm text-gray-400">
                                Par <span class="font-mono text-gray-300">${senderName}</span>
                                ${' à '}
                                ${loc.timestamp ? new Date(loc.timestamp).toLocaleTimeString('fr-FR') : 'N/A'}
                            </p>
                        </div>
                    </div>
                `;
                }).join('');
            }
        }

        // Rendu du contenu de l'onglet "Objectifs" (anciennement "Défis")
        function renderObjectifsTab() {
            document.getElementById('tabContent').innerHTML = `
                <div>
                    <h2 class="text-3xl font-semibold mb-6 text-center text-red-400">Objectifs du Festival</h2>
                    <div id="userGaugesContainer" class="flex justify-around items-end mb-8 flex-wrap gap-6">
                        <!-- Les jauges individuelles seront insérées ici par updateChallengeGauges() -->
                    </div>
                    <div class="flex flex-col sm:flex-row gap-3 mb-6">
                        <input
                            type="text"
                            id="newChallengeInput"
                            placeholder="Ajouter un nouvel objectif..."
                            class="input-field flex-grow"
                        />
                        <button onclick="addChallengeEvent()" class="btn-primary">
                            Ajouter
                        </button>
                    </div>
                    <div id="challengesList" class="scrollable-content">
                        <!-- Les objectifs seront injectés ici -->
                    </div>
                </div>
            `;
            updateChallengesDisplay(); // Mettre à jour l'affichage initial des objectifs
            updateChallengeGauges(); // Initialiser les jauges des objectifs
        }

        // Mettre à jour l'affichage des défis (maintenant objectifs)
        function updateChallengesDisplay() {
            const listElement = document.getElementById('challengesList');
            if (!listElement) return;

            if (challenges.length === 0) {
                listElement.innerHTML = `<p class="text-center text-gray-400 italic">Aucun objectif ajouté pour l'instant.</p>`;
            } else {
                listElement.innerHTML = challenges.map(challenge => {
                    const completedByName = challenge.completedBy && userProfiles[challenge.completedBy] ? escapeHTML(userProfiles[challenge.completedBy].firstName) : 'Inconnu';
                    return `
                    <div class="card flex items-center justify-between">
                        <label class="flex items-center cursor-pointer flex-grow">
                            <input
                                type="checkbox"
                                ${challenge.completed ? 'checked' : ''}
                                onchange="toggleChallengeCompletionEvent('${challenge.id}', this.checked)"
                                class="form-checkbox h-6 w-6 text-red-600 rounded mr-3 bg-gray-700 border-gray-600 checked:bg-red-600 focus:ring-red-500"
                            />
                            <span class="text-lg ${challenge.completed ? 'line-through text-gray-500' : 'text-white'}">
                                ${escapeHTML(challenge.text)}
                            </span>
                        </label>
                        ${challenge.completed ? `<span class="text-sm text-green-400 ml-2">Complété par ${completedByName}</span>` : ''}
                    </div>
                `;
                }).join('');
            }
        }

        // --- Fonctions de mise à jour des jauges de défis (maintenant objectifs) ---
        function updateChallengeGauges() {
            const gaugesContainer = document.getElementById('userGaugesContainer');
            if (!gaugesContainer) return;

            // Filtrer les profils pour n'afficher que ceux qui ont un prénom
            const identifiableUsers = Object.values(userProfiles).filter(p => p.firstName);

            if (identifiableUsers.length === 0) {
                gaugesContainer.innerHTML = `<p class="text-center text-gray-400 italic">Connectez-vous pour voir la progression des objectifs des joueurs !</p>`;
                return;
            }

            gaugesContainer.innerHTML = ''; // Effacer les jauges précédentes

            const usersToDisplay = identifiableUsers.sort((a, b) => {
                // Tri pour que l'utilisateur actuel apparaisse en premier, puis les autres par prénom
                if (a.userId === currentUserId) return -1;
                if (b.userId === currentUserId) return 1;
                return a.firstName.localeCompare(b.firstName);
            }).slice(0, 2); // Limiter à 2 utilisateurs pour les jauges

            // Pour les jauges circulaires
            const radius = 45; // Rayon du cercle
            const circumference = 2 * Math.PI * radius; // Circonférence du cercle


            usersToDisplay.forEach(profile => {
                const userIdToDisplay = profile.userId;
                const userCompletedChallenges = challenges.filter(c => c.completedBy === userIdToDisplay).length;
                const totalChallengesExisting = challenges.length;
                // Le pourcentage est basé sur les défis complétés par ce joueur par rapport au total des défis existants.
                const completionPercentage = totalChallengesExisting > 0 ? (userCompletedChallenges / totalChallengesExisting) * 100 : 0; // 0.0 to 100.0

                const userName = escapeHTML(profile.firstName);

                // Calcul pour le cercle
                const strokeDashoffset = circumference - (completionPercentage / 100) * circumference;

                const gaugeHtml = `
                    <div class="gauge-item-wrapper">
                        <svg class="gauge-svg" viewBox="0 0 100 100">
                            <circle cx="50" cy="50" r="${radius}" class="gauge-bg"></circle>
                            <circle cx="50" cy="50" r="${radius}" class="gauge-progress"
                                style="stroke-dasharray: ${circumference}; stroke-dashoffset: ${strokeDashoffset};"></circle>
                        </svg>
                        <div class="gauge-text-overlay">${userCompletedChallenges}</div>
                        <div class="gauge-label-overlay">${userName}</div>
                    </div>
                `;
                gaugesContainer.innerHTML += gaugeHtml;
            });
        }

        // Rendu du contenu de l'onglet "Se connecter"
        function renderConnectTab() {
            document.getElementById('tabContent').innerHTML = `
                <div>
                    <h2 class="text-3xl font-semibold mb-6 text-center text-red-400">Mon Profil</h2>
                    <p class="text-center text-gray-400 mb-4">
                        Enregistrez votre prénom et numéro de téléphone pour que vos amis vous reconnaissent.
                    </p>
                    <div class="flex flex-col gap-4 mb-6">
                        <input
                            type="text"
                            id="firstNameInput"
                            placeholder="Votre prénom"
                            class="input-field"
                        />
                        <input
                            type="tel"
                            id="phoneNumberInput"
                            placeholder="Votre numéro de téléphone"
                            class="input-field"
                            oninput="formatPhoneNumber(this)"
                            maxlength="14" />
                        <button onclick="saveProfile()" class="btn-primary">
                            Enregistrer le profil
                        </button>
                    </div>
                    <div class="text-center text-gray-500 mt-6 text-sm">
                        Votre ID unique: <span class="font-mono bg-gray-700 rounded px-2 py-1">${currentUserId ? currentUserId : 'Chargement...'}</span>
                    </div>
                </div>
            `;
            // Pre-fill fields if profile already exists
            if (currentUserId && userProfiles[currentUserId]) {
                document.getElementById('firstNameInput').value = userProfiles[currentUserId].firstName || '';
                // Format the phone number when pre-filling
                const rawPhoneNumber = userProfiles[currentUserId].phoneNumber || '';
                document.getElementById('phoneNumberInput').value = window.formatPhoneNumber({ value: rawPhoneNumber });
            }
        }

        // Update the display of the online users count
        function updateOnlineUsersCountDisplay() {
            const displayElement = document.getElementById('onlineUsersCount');
            if (displayElement) {
                displayElement.textContent = `En ligne: ${onlineUsersCount}`;
            }
        }

        // --- Countdown Functions ---
        function startCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval); // Ensure there's only one active interval
            }
            countdownInterval = setInterval(updateCountdown, 1000); // Update every second
            updateCountdown(); // Call once immediately to avoid initial delay
        }

        function updateCountdown() {
            const now = new Date().getTime();
            const countdownText = document.querySelector('#countdownDisplay .countdown-text');
            const countdownLabel = document.querySelector('#countdownDisplay .countdown-label');


            if (!countdownText || !countdownLabel) {
                clearInterval(countdownInterval); // Stop if the element no longer exists
                return;
            }

            if (now < DEFQON_START_DATE.getTime()) {
                // Before the festival starts: Display countdown
                const distance = DEFQON_START_DATE.getTime() - now;

                const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);

                countdownText.innerHTML = `${days}j ${hours}h ${minutes}m ${seconds}s`;
                // Clear the label
                countdownLabel.textContent = '';
                countdownLabel.classList.remove('visible'); // Hide the label


            } else if (now >= DEFQON_START_DATE.getTime() && now <= DEFQON_END_DATE.getTime()) {
                // During the festival: Display Day 1, Day 2, etc.
                const oneDay = 1000 * 60 * 60 * 24;
                const diffDays = Math.floor((now - DEFQON_START_DATE.getTime()) / oneDay);
                let festivalDay = diffDays + 1; // Day 1 = diff 0, Day 2 = diff 1, etc.

                if (festivalDay > 4) { // Ensure not to exceed Day 4 if the festival is over
                    countdownText.innerHTML = "Terminé !";
                    countdownLabel.textContent = "Le festival Defqon 1 est terminé pour cette année !";
                    countdownLabel.classList.add('visible'); // Show the label
                    countdownLabel.classList.add('font-bold'); // Make the label bold
                    clearInterval(countdownInterval);
                } else {
                    countdownText.innerHTML = `Jour ${festivalDay}`;
                    countdownLabel.textContent = `Profitez de la Defqon 1 !`;
                    countdownLabel.classList.add('visible'); // Show the label
                    countdownLabel.classList.add('font-bold'); // Make the label bold
                }
            } else {
                // After the festival ends
                countdownText.innerHTML = "Terminé !";
                countdownLabel.textContent = "Le festival Defqon 1 est terminé pour cette année !";
                countdownLabel.classList.add('visible'); // Show the label
                countdownLabel.classList.add('font-bold'); // Make the label bold
                clearInterval(countdownInterval); // Stop the countdown
            }
        }

        // Function to activate a tab
        // Expose the function to the global scope
        window.setActiveTab = function(tabName) {
            // Mettre à jour les classes des boutons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
                button.classList.remove('scale-105');
            });
            // Pour le bouton Se connecter (séparé)
            const tabConnectButton = document.getElementById('tabConnect');
            if (tabConnectButton) {
                tabConnectButton.classList.remove('active');
                tabConnectButton.classList.remove('scale-105');
            }

            // Assurez-vous que l'élément existe avant de tenter d'ajouter la classe 'active'
            const targetButton = document.getElementById('tab' + tabName.charAt(0).toUpperCase() + tabName.slice(1));
            if (targetButton) {
                targetButton.classList.add('active');
            } else if (tabName === 'connect' && tabConnectButton) {
                tabConnectButton.classList.add('active');
            }


            // Afficher le contenu de l'onglet
            switch (tabName) {
                case 'accueil':
                    renderAccueilTab();
                    break;
                case 'seRetrouver':
                    renderSeRetrouverTab();
                    break;
                case 'objectifs': // Ancien 'defis'
                    renderObjectifsTab();
                    break;
                case 'connect':
                    renderConnectTab();
                    break;
                default:
                    renderAccueilTab(); // Revenir à l'onglet par défaut si un onglet invalide est demandé
            }
        }

        // --- APPLICATION INITIALIZATION (après chargement du DOM) ---
        // Le `DOMContentLoaded` est maintenant géré dans `onAuthStateChanged` pour s'assurer
        // que l'authentification Firebase est prête avant de rendre le contenu initial.
        // Assurez-vous d'arrêter le compte à rebours lorsque la page est déchargée
        window.addEventListener('beforeunload', () => {
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
        });
    </script>
</body>
</html>
