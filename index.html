<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEFQON 1 Companion - Avec Firestore</title>
    <!-- Chargement de Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chargement de la bibliothèque QRious pour les QR Codes -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
    <style>
        /* Importation de la police Inter */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000; /* Noir profond pour le fond (Defqon style) */
            color: #ffffff; /* Texte blanc */
        }
        /* Styles pour les boutons d'onglets */
        .tab-button {
            @apply px-4 py-2 rounded-md transition-all duration-300 ease-in-out transform; /* Ajout de transform pour les animations */
        }
        .tab-button.active {
            /* Changement: fond transparent, bordure inférieure rouge subtile, texte rougeoyant */
            @apply bg-transparent text-red-400 scale-105; 
            border: none; /* Pas de bordure pleine */
            border-bottom: 2px solid #dc2626; /* Bordure inférieure rouge */
            box-shadow: none; /* Pas d'ombre de boîte pour éviter l'effet rectangulaire */
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); /* Lueur sur le texte */
        }
        .tab-button:not(.active) {
            @apply bg-gray-800 text-gray-300 hover:bg-gray-700 hover:scale-105 active:scale-95; /* Gris foncé, survol et clic */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Ombre par défaut */
        }
        .tab-button:not(.active):hover {
            box-shadow: 0 0 20px rgba(220, 38, 38, 0.7); /* Ombre rouge plus intense au survol */
        }

        /* Styles pour les champs de saisie */
        .input-field {
            /* Utilisation d'un gris un peu plus clair pour un meilleur contraste */
            @apply w-full p-3 rounded-md bg-gray-700 border border-gray-600 focus:ring-2 focus:ring-red-500 focus:border-transparent transition-all;
            color: #333333 !important; /* Rendre le texte tapé explicitement gris foncé (presque noir) et prioritaire */
        }
        .input-field::placeholder { /* Couleur pour le texte de substitution */
            color: #a0aec0 !important; /* Un gris plus clair pour les placeholders et prioritaire */
            opacity: 1; /* Assure que le placeholder n'est pas transparent */
        }
        /* Styles pour les boutons principaux (submit) */
        .btn-primary {
            @apply px-6 py-3 rounded-md bg-red-700 text-white font-semibold transition-all shadow-md transform hover:scale-105 active:scale-95; /* Rouge vif, survol et clic */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Ombre par défaut */
        }
        .btn-primary:hover {
            box-shadow: 0 0 25px rgba(220, 38, 38, 0.8); /* Ombre rouge au survol */
        }

        /* Styles pour les cartes de contenu */
        .card {
            @apply bg-gray-900 p-4 rounded-lg shadow-lg mb-4; /* Gris très foncé pour les cartes */
        }
        /* Styles pour les zones de contenu défilantes */
        .scrollable-content {
            max-height: 70vh; /* Hauteur maximale pour le défilement */
            overflow-y: auto; /* Permet le défilement vertical */
            scrollbar-width: thin; /* Style de la barre de défilement pour Firefox */
            scrollbar-color: #880808 #333333; /* Couleurs de la barre de défilement pour Firefox (Rouge/Noir) */
        }
        /* Styles de la barre de défilement pour Webkit (Chrome, Safari) */
        .scrollable-content::-webkit-scrollbar {
            width: 8px;
        }
        .scrollable-content::-webkit-scrollbar-track {
            background: #333333; /* Noir/Gris pour le fond de la barre */
            border-radius: 10px;
        }
        .scrollable-content::-webkit-scrollbar-thumb {
            background-color: #880808; /* Rouge pour le curseur de la barre */
            border-radius: 10px;
            border: 2px solid #333333;
        }
        /* Styles pour la boîte de message personnalisée */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #222; /* Gris foncé */
            color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none; /* Caché par défaut */
        }
        .message-box button {
            background-color: #dc2626; /* Rouge */
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }

        /* Styles pour les jauges circulaires (REVISITÉES) */
        .gauge-item-wrapper {
            display: flex;
            flex-direction: column; /* Organise en colonne: jauge puis nom */
            align-items: center;
            min-width: 150px; /* Assure un espace minimum pour chaque jauge */
            height: 200px; /* Hauteur de la zone pour la jauge et le nom */
            justify-content: center; /* Centrer la jauge verticalement */
            position: relative; /* Pour positionner correctement le SVG et les textes */
        }
        .gauge-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: visible; /* Assure que le stroke ne soit pas coupé */
        }
        .gauge-bg {
            stroke: #333333; /* Couleur de fond de la jauge */
            stroke-width: 15;
            fill: none;
        }
        .gauge-progress {
            stroke: #dc2626; /* Rouge Defqon pour la progression */
            stroke-width: 15;
            fill: none;
            transition: stroke-dasharray 0.5s ease-in-out; /* Animation fluide */
            stroke-linecap: round; /* Rendre les extrémités de la barre arrondies */
            filter: drop-shadow(0 0 5px rgba(220, 38, 38, 0.7)); /* Ombre pour la lueur */
            transform: rotate(-90deg); /* Rotation pour démarrer en haut */
            transform-origin: 50% 50%; /* Point de pivot pour la rotation */
        }
        .gauge-text-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 2.5rem; /* Taille plus grande pour le nombre */
            font-weight: bold;
            text-align: center;
            z-index: 1; /* Assure que le texte est au-dessus du SVG */
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); /* Lueur sur le texte */
        }
        .gauge-label-overlay {
            position: absolute;
            top: 75%; /* Positionnement de l'étiquette sous le nombre */
            left: 50%;
            transform: translate(-50%, -50%);
            color: #a0aec0; /* Gris clair */
            font-size: 1rem; /* Taille de police légèrement plus grande */
            text-align: center;
            z-index: 1; /* Assure que le texte est au-dessus du SVG */
        }


        /* Style pour le timer */
        @keyframes subtle-glow {
            0% { box-shadow: 0 0 15px rgba(220, 38, 38, 0.6), inset 0 0 8px rgba(220, 38, 38, 0.3); border-color: #dc2626; }
            50% { box-shadow: 0 0 40px rgba(220, 38, 38, 1), inset 0 0 15px rgba(220, 38, 38, 0.5); border-color: #ef4444; }
            100% { box-shadow: 0 0 15px rgba(220, 38, 38, 0.6), inset 0 0 8px rgba(220, 38, 38, 0.3); border-color: #dc2626; }
        }
        .countdown-box {
            @apply bg-gray-900 border-2 border-red-700 p-4 rounded-xl text-center mb-8 flex items-center justify-center;
            animation: subtle-glow 2.5s infinite alternate;
            width: 90%;
            max-width: 400px;
            height: 90px;
            overflow: hidden;
        }
        .countdown-box .countdown-text {
            /* Utilisation d'une taille de police ajustée pour remplir l'espace sans déborder */
            font-size: 1.4rem; /* Taille de base ajustée */
            @apply text-white font-bold;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.9), 0 0 30px rgba(255, 0, 0, 0.7);
            white-space: nowrap; /* Empêche le retour à la ligne */
            overflow: hidden; /* Cache le texte qui dépasse */
            text-overflow: ellipsis; /* Ajoute des points de suspension si le texte est trop long */
            
            /* Flexbox pour le centrage parfait */
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%; /* S'assurer que le texte prend toute la hauteur disponible pour le centrage */
            width: 100%; /* S'assurer que le texte prend toute la largeur disponible */
        }
        /* Ajustements responsifs pour la taille de la police du minuteur */
        @media (min-width: 640px) { /* sm */
            .countdown-box .countdown-text {
                font-size: 1.8rem;
            }
        }
        @media (min-width: 768px) { /* md */
            .countdown-box .countdown-text {
                font-size: 2.2rem;
            }
        }
        @media (min-width: 1024px) { /* lg */
            .countdown-box .countdown-text {
                font-size: 2.6rem;
            }
        }

        .countdown-box .countdown-label {
            display: none;
        }
        .countdown-box .countdown-label.visible {
            display: block;
            @apply text-red-400 text-base sm:text-lg font-semibold mt-1;
        }

    </style>
</head>
<body class="min-h-screen p-4 sm:p-6 lg:p-8 flex flex-col items-center">
    <h1 class="text-4xl sm:text-5xl font-bold text-center mb-8 text-red-500">DEFQON 1 Companion</h1>

    <!-- Conteneur des onglets et du bouton de connexion -->
    <div class="flex flex-col sm:flex-row items-center justify-center mb-8 gap-4">
        <!-- Onglets de navigation -->
        <div class="flex space-x-2 sm:space-x-4 p-1 bg-gray-800 rounded-lg shadow-inner">
            <button id="tabAccueil" class="tab-button" onclick="setActiveTab('accueil')">
                Accueil
            </button>
            <button id="tabSeRetrouver" class="tab-button" onclick="setActiveTab('seRetrouver')">
                Se retrouver
            </button>
            <button id="tabObjectifs" class="tab-button" onclick="setActiveTab('objectifs')">
                Objectifs
            </button>
            <button id="tabTchat" class="tab-button" onclick="setActiveTab('tchat')">
                Tchat
            </button>
        </div>
        <!-- Bouton "Se connecter" / "Mon Profil" -->
        <button id="tabConnect" class="px-4 py-2 rounded-md bg-red-700 text-white font-semibold transition-all shadow-lg hover:bg-red-800 hover:scale-105 active:scale-95 transform" onclick="setActiveTab('connect')">
            S'enregistrer
        </button>
        <!-- Nouveau bouton "NoisyNeighbors" -->
        <button id="tabNoisyNeighbors" class="px-4 py-2 rounded-md bg-purple-700 text-white font-semibold transition-all shadow-lg hover:bg-purple-800 hover:scale-105 active:scale-95 transform" onclick="setActiveTab('noisyNeighbors')">
            NoisyNeighbors
        </button>
    </div>

    <!-- Contenu des onglets -->
    <div id="tabContent" class="w-full max-w-2xl bg-gray-900 p-6 rounded-xl shadow-2xl">
        <!-- Le contenu des onglets sera injecté ici par JavaScript -->
    </div>

    <!-- Message Box (remplace alert() et confirm()) -->
    <div id="messageBox" class="message-box">
        <p id="messageBoxContent"></p>
        <button onclick="hideMessageBox()">OK</button>
    </div>

    <!-- Script Firebase SDKs -->
    <script type="module">
        // Importation des modules Firebase nécessaires via CDN
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, addDoc, updateDoc, query, orderBy, limit, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL CONSTANTS AND INITIALIZATION ---
        // Global variables __app_id, __firebase_config and __initial_auth_token
        // are provided by the Canvas environment.
        // We use default values in case they are not defined (e.g., for local testing).
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-defqon-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let firebaseConfig = {};
        // Vérifie si __firebase_config est défini (utilisé par Canvas)
        if (typeof __firebase_config !== 'undefined' && __firebase_config) {
            try {
                firebaseConfig = JSON.parse(__firebase_config);
            } catch (e) {
                console.error("Erreur lors de l'analyse de __firebase_config:", e);
            }
        } else {
            console.warn("Attention: __firebase_config n'est pas défini. Si vous exécutez cette application en dehors de l'environnement Canvas, veuillez remplacer 'YOUR_FIREBASE_CONFIG_HERE' par votre configuration Firebase réelle.");
            firebaseConfig = {
                apiKey: "AIzaSyAb5BBuf3qfFFMpXTwIp3XjBCf_VIIBsWo", 
                authDomain: "defqon1-9f38d.firebaseapp.com",
                projectId: "defqon1-9f38d",
                storageBucket: "defqon1-9f38d.firebasestorage.app",
                messagingSenderId: "123287772879",
                appId: "1:123287772879:web:a76c3c0de2a47b1ac5a1ba",
                measurementId: "G-40W1R1M7CC"
                };
        }

        let currentUserId = null;
        let firebaseApp;
        let db;
        let auth;
        let isAuthReady = false; // Indique si l'authentification est prête
        let hasUserProfile = false; // Nouveau drapeau pour savoir si l'utilisateur a un profil enregistré
        let onlineUsersCount = 0; // Initialisation de la variable pour le nombre d'utilisateurs en ligne

        // Constants for Defqon 1 countdown
        const DEFQON_START_DATE = new Date('2025-06-26T12:00:00'); // June 26, 2025, 12:00 PM
        const DEFQON_END_DATE = new Date('2025-06-29T23:59:59'); // June 29, 2025, 11:59 PM (for 4 days until Sunday evening)
        let countdownInterval = null;

        // --- URLS POUR LES QR CODES ---
        const INSTAGRAM_URL = "https://www.instagram.com/noisyneighborsmusic?igsh=MW5rZzJ4ajBpdDVvMA%3D%3D&utm_source=qr";
        const SOUNDCLOUD_URL = "https://soundcloud.com/noisyneighborsmusics?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing";

        // --- VARIABLES GLOBALES POUR LES DONNÉES FIRESTORE ---
        let locationMessages = []; // Tableau local pour stocker les messages de localisation (texte)
        let chatMessages = []; // Tableau local pour stocker les messages de chat
        let challenges = []; // Tableau local pour stocker les défis (maintenant appelés objectifs)
        let userProfiles = {}; // Stocke les profils des utilisateurs


        // --- UTILITY FUNCTIONS ---

        // Function to generate a UUID (Universally Unique Identifier)
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Utility function to escape HTML and prevent XSS
        function escapeHTML(str) {
            const div = document.createElement('div');
            div.appendChild(document.createTextNode(str));
            return div.innerHTML;
        }

        // --- CUSTOM ALERT MESSAGE BOX HANDLING ---
        // Expose the function to the global scope so it can be called from HTML
        window.showMessageBox = function(message) {
            const msgBox = document.getElementById('messageBox');
            const msgContent = document.getElementById('messageBoxContent');
            msgContent.textContent = message;
            msgBox.style.display = 'block';
        }

        // Expose the function to the global scope
        window.hideMessageBox = function() {
            document.getElementById('messageBox').style.display = 'none';
        }

        // --- FIREBASE INITIALIZATION ---
        (async () => { // Utilisez une IIFE pour les opérations asynchrones au chargement du script
            try {
                firebaseApp = initializeApp(firebaseConfig);
                db = getFirestore(firebaseApp);
                auth = getAuth(firebaseApp);

                // Set up the authentication state listener FIRST
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        const userProfileRef = doc(db, `artifacts/${appId}/public/data/profiles`, currentUserId);
                        const profileSnap = await getDoc(userProfileRef);
                        hasUserProfile = profileSnap.exists() && profileSnap.data().firstName;
                        console.log("ID utilisateur défini sur :", currentUserId);
                    } else {
                        // No user is authenticated, attempt to sign in (anonymously or with custom token)
                        console.log("Aucun utilisateur authentifié. Tentative de connexion...");
                        try {
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                                console.log("Connecté avec jeton personnalisé via onAuthStateChanged fallback.");
                            } else {
                                await signInAnonymously(auth);
                                console.log("Connecté anonymement via onAuthStateChanged fallback.");
                            }
                            // If sign-in succeeds, onAuthStateChanged will re-fire with the user object.
                            // So, we don't call setupFirestoreListeners here directly.
                        } catch (signInError) {
                            console.error("Erreur de connexion anonyme ou par jeton personnalisé :", signInError);
                            showMessageBox("Impossible de se connecter au service d'authentification. Certaines fonctionnalités peuvent être limitées.");
                            currentUserId = generateUUID(); // Fallback local ID if auth fails
                        }
                        hasUserProfile = false; // Reset profile status
                    }

                    // This part ensures that Firebase is ready AND we have a currentUserId (even a local fallback)
                    // before proceeding with setting up listeners and UI.
                    isAuthReady = true; // Authentication state is resolved for this cycle
                    updateConnectButtonState();
                    // Ensure db and auth are initialized and currentUserId is set before setting up listeners
                    if (db && auth && currentUserId) { 
                         setupFirestoreListeners();
                    } else {
                         console.warn("Firestore listeners non configurés car l'authentification a échoué ou l'ID utilisateur est manquant.");
                    }
                    window.setActiveTab('accueil'); // Always show the home tab initially
                });

            } catch (error) {
                console.error("Erreur lors de l'initialisation de Firebase :", error);
                showMessageBox("Erreur critique : Impossible d'initialiser l'application. Veuillez vérifier la configuration Firebase.");
                db = null;
                auth = null;
                isAuthReady = true;
                window.setActiveTab('accueil');
            }
        })(); // Fin de l'IIFE


        // --- FIRESTORE OPERATIONS ---

        // Set up Firestore listeners once authentication is ready
        function setupFirestoreListeners() {
            if (!db || !isAuthReady) return; // Ensure Firebase is initialized and auth is ready

            // Écouteur pour les messages de localisation (texte)
            const locationsColRef = collection(db, `artifacts/${appId}/public/data/locations`);
            onSnapshot(locationsColRef, (snapshot) => {
                const fetchedLocations = [];
                snapshot.forEach(doc => {
                    fetchedLocations.push({ id: doc.id, ...doc.data() });
                });
                fetchedLocations.sort((a, b) => b.timestamp - a.timestamp);
                locationMessages = fetchedLocations;
                updateLocationMessagesDisplay();
            }, (error) => {
                console.error("Erreur lors de l'écoute des messages de localisation:", error);
                showMessageBox("Impossible de charger les messages de localisation en temps réel.");
            });

            // Écouteur pour les défis (maintenant objectifs)
            const challengesColRef = collection(db, `artifacts/${appId}/public/data/challenges`);
            onSnapshot(challengesColRef, (snapshot) => {
                const fetchedChallenges = [];
                snapshot.forEach(doc => {
                    fetchedChallenges.push({ id: doc.id, ...doc.data() });
                });
                challenges = fetchedChallenges;
                updateChallengesDisplay();
                updateChallengeGauges();
            }, (error) => {
                console.error("Erreur lors de l'écoute des objectifs:", error);
                showMessageBox("Impossible de charger les objectifs en temps réel.");
            });

            // Écouteur pour les messages de chat
            const chatColRef = query(collection(db, `artifacts/${appId}/public/data/chatMessages`), orderBy('timestamp', 'asc'), limit(50)); // Limite à 50 derniers messages
            onSnapshot(chatColRef, (snapshot) => {
                const fetchedMessages = [];
                snapshot.forEach(doc => {
                    fetchedMessages.push({ id: doc.id, ...doc.data() });
                });
                chatMessages = fetchedMessages;
                updateChatDisplay(); // Mettre à jour l'affichage du chat
            }, (error) => {
                console.error("Erreur lors de l'écoute des messages de chat:", error);
                showMessageBox("Impossible de charger les messages de chat en temps réel.");
            });

            // Écouteur pour les profils utilisateurs et la présence en ligne
            const profilesColRef = collection(db, `artifacts/${appId}/public/data/profiles`);
            onSnapshot(profilesColRef, (snapshot) => {
                const fetchedProfiles = {};
                let count = 0;
                const now = Date.now();
                
                snapshot.forEach(doc => {
                    const profile = { id: doc.id, ...doc.data() };
                    fetchedProfiles[doc.id] = profile;
                    if (profile.lastOnline && profile.lastOnline > (now - 60000)) { // 60s pour le compteur "En ligne"
                        count++;
                    }
                });
                userProfiles = fetchedProfiles; // Mettre à jour le cache des profils
                onlineUsersCount = count; // Mettre à jour le compteur

                // Mettre à jour hasUserProfile basé sur le profil actuel
                hasUserProfile = userProfiles[currentUserId] && userProfiles[currentUserId].firstName;
                updateConnectButtonState(); // Mettre à jour le bouton de connexion/profil

                updateOnlineUsersCountDisplay(); // Mettre à jour l'affichage du compteur
                updateChallengeGauges(); // Mettre à jour les jauges des objectifs
                updateChatDisplay(); // S'assurer que les noms d'utilisateur sont à jour dans le chat
            }, (error) => {
                console.error("Erreur lors de l'écoute des profils utilisateurs:", error);
                showMessageBox("Impossible de charger les profils utilisateurs.");
            });

            // Mise à jour périodique du statut "lastOnline" de l'utilisateur actuel
            setInterval(async () => {
                if (db && currentUserId && isAuthReady) {
                    try {
                        const userProfileRef = doc(db, `artifacts/${appId}/public/data/profiles`, currentUserId);
                        await setDoc(userProfileRef, { lastOnline: Date.now() }, { merge: true }); 
                    }
                     catch (error) {
                        console.error("Erreur lors de la mise à jour du statut en ligne:", error);
                    }
                }
            }, 30000); // Mettre à jour toutes les 30 secondes
        }

        // --- FONCTIONS D'ENVOI DE DONNÉES À FIRESTORE ---

        // Fonction pour envoyer le message de localisation (texte) à Firestore
        window.sendLocationMessageEvent = async function() {
            if (!db || !currentUserId) {
                showMessageBox("L'application n'est pas prête ou l'utilisateur n'est pas authentifié.");
                return;
            }
            const inputElement = document.getElementById('locationMessageInput');
            const message = inputElement.value.trim();
            if (message === '') return;

            try {
                const locationDocRef = doc(db, `artifacts/${appId}/public/data/locations`, currentUserId); // Utilise l'ID utilisateur comme ID de doc pour la dernière position texte
                await setDoc(locationDocRef, {
                    userId: currentUserId,
                    message: message,
                    timestamp: Date.now(),
                }, { merge: true }); // Utilise merge pour ne pas écraser les coordonnées si elles existent
                inputElement.value = '';
            } catch (error) {
                console.error("Erreur lors de l'envoi du message de localisation:", error);
                showMessageBox("Erreur lors de l'envoi du message de localisation.");
            }
        }

        // Fonction pour ajouter un nouveau défi (objectif) à Firestore
        window.addChallengeEvent = async function() {
            if (!db || !currentUserId) {
                showMessageBox("L'application n'est pas prête ou l'utilisateur n'est pas authentifié.");
                return;
            }
            const inputElement = document.getElementById('newChallengeInput');
            const text = inputElement.value.trim();
            if (text === '') return;

            try {
                await addDoc(collection(db, `artifacts/${appId}/public/data/challenges`), {
                    text: text,
                    completed: false,
                    createdBy: currentUserId,
                    createdAt: Date.now(),
                });
                inputElement.value = '';
            } catch (error) {
                console.error("Erreur lors de l'ajout de l'objectif:", error);
                showMessageBox("Erreur lors de l'ajout de l'objectif.");
            }
        }

        // Fonction pour basculer l'état "complété" d'un défi (objectif) dans Firestore
        window.toggleChallengeCompletionEvent = async function(challengeId, newStatus) {
            if (!db || !currentUserId) {
                showMessageBox("L'application n'est pas prête ou l'utilisateur n'est pas authentifié.");
                return;
            }
            try {
                const challengeRef = doc(db, `artifacts/${appId}/public/data/challenges`, challengeId);
                await updateDoc(challengeRef, {
                    completed: newStatus,
                    completedBy: newStatus ? currentUserId : null,
                    completedAt: newStatus ? Date.now() : null,
                });
            } catch (error) {
                console.error("Erreur lors de la mise à jour de l'objectif:", error);
                showMessageBox("Erreur lors de la mise à jour de l'objectif.");
            }
        }

        // Fonction pour envoyer un message de chat à Firestore
        window.sendChatMessage = async function() {
            // Vérifier si l'utilisateur a un profil enregistré (prénom) pour envoyer des messages
            if (!currentUserId || !hasUserProfile) {
                showMessageBox("Veuillez vous enregistrer (onglet S'enregistrer) pour pouvoir envoyer des messages.");
                return;
            }
            if (!db) { // Fallback si Firebase n'est pas initialisé
                 showMessageBox("L'application n'est pas prête.");
                 return;
            }

            const chatInput = document.getElementById('chatMessageInput');
            const messageText = chatInput.value.trim();

            if (!messageText) {
                return; // Ne pas envoyer de message vide
            }

            try {
                await addDoc(collection(db, `artifacts/${appId}/public/data/chatMessages`), {
                    userId: currentUserId,
                    message: messageText,
                    timestamp: Date.now(),
                });
                chatInput.value = ''; // Effacer le champ de saisie
                // Faire défiler vers le bas après l'envoi
                const chatMessagesContainer = document.getElementById('chatMessagesContainer');
                if (chatMessagesContainer) {
                    chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
                }
            } catch (error) {
                console.error("Erreur lors de l'envoi du message de chat:", error);
                showMessageBox("Erreur lors de l'envoi du message.");
            }
        };

        // --- VALIDATION ET FORMATAGE DU NUMÉRO DE TÉLÉPHONE ---
        window.formatPhoneNumber = function(input) {
            let value = input.value.replace(/\D/g, '');
            let formattedValue = '';
            for (let i = 0; i < value.length; i++) {
                if (i > 0 && i % 2 === 0) {
                    formattedValue += ' ';
                }
                formattedValue += value[i];
            }
            input.value = formattedValue;
            return formattedValue;
        }

        // Fonction pour enregistrer ou mettre à jour le profil utilisateur
        window.saveProfile = async function() {
            if (!db || !currentUserId) {
                showMessageBox("L'application n'est pas prête ou l'utilisateur n'est pas authentifié.");
                return;
            }

            const firstNameInput = document.getElementById('firstNameInput');
            const phoneNumberInput = document.getElementById('phoneNumberInput');
            const firstName = firstNameInput.value.trim();
            let phoneNumber = phoneNumberInput.value.replace(/\s/g, '');

            if (!firstName) {
                showMessageBox("Veuillez saisir votre prénom.");
                return;
            }
            if (!/^\d{10}$/.test(phoneNumber)) {
                showMessageBox("Le numéro de téléphone doit contenir exactement 10 chiffres (ex: 0612345678).");
                return;
            }

            try {
                const userProfileRef = doc(db, `artifacts/${appId}/public/data/profiles`, currentUserId);
                
                // Si l'utilisateur a déjà un profil et tente de s'enregistrer avec des données identiques,
                // ou s'il y a déjà un prénom enregistré, on peut le considérer comme un doublon pour cette session anonyme.
                if (hasUserProfile && userProfiles[currentUserId]?.firstName === firstName && userProfiles[currentUserId]?.phoneNumber === phoneNumber) {
                    showMessageBox("Votre profil est déjà enregistré avec ces informations.");
                    return;
                }

                await setDoc(userProfileRef, {
                    userId: currentUserId,
                    firstName: firstName,
                    phoneNumber: phoneNumber,
                    lastOnline: Date.now()
                }, { merge: true });
                showMessageBox("Votre profil a été enregistré avec succès !");
                
                // Mettre à jour l'état et l'UI immédiatement
                hasUserProfile = true;
                updateConnectButtonState(); // Mettre à jour le texte du bouton principal
                renderProfileTab(); // Re-rendre l'onglet pour afficher le profil
                
            } catch (error) {
                console.error("Erreur lors de l'enregistrement du profil:", error);
                showMessageBox("Erreur lors de l'enregistrement de votre profil.");
            }
        }

        // Fonction pour déconnecter l'utilisateur
        window.logout = async function() {
            try {
                if (auth.currentUser) {
                    await signOut(auth); // Déconnecte l'utilisateur Firebase
                }
                // Réinitialiser l'état local et forcer le rechargement pour obtenir un nouvel utilisateur anonyme
                currentUserId = null;
                hasUserProfile = false;
                userProfiles = {}; // Effacer les profils en cache
                updateConnectButtonState(); // Mettre à jour le bouton
                window.location.reload(); // Recharger la page pour un nouvel utilisateur anonyme
            } catch (error) {
                console.error("Erreur lors de la déconnexion:", error);
                showMessageBox("Erreur lors de la déconnexion: " + error.message);
            }
        };

        // Fonction pour mettre à jour le texte du bouton de connexion/profil
        function updateConnectButtonState() {
            const tabConnectButton = document.getElementById('tabConnect');
            if (tabConnectButton) {
                if (hasUserProfile) {
                    tabConnectButton.textContent = "Mon Profil";
                    // Ajouter des classes spécifiques si nécessaire pour un état "connecté"
                    tabConnectButton.classList.remove('bg-red-700', 'hover:bg-red-800');
                    tabConnectButton.classList.add('bg-green-700', 'hover:bg-green-800'); // Exemple de couleur différente pour "connecté"
                } else {
                    tabConnectButton.textContent = "S'enregistrer";
                    // Revenir aux classes par défaut si déconnecté/non enregistré
                    tabConnectButton.classList.remove('bg-green-700', 'hover:bg-green-800');
                    tabConnectButton.classList.add('bg-red-700', 'hover:bg-red-800');
                }
            }
        }


        // --- RENDU DES ONGLES ET MISE À JOUR DE L'AFFICHAGE ---

        // Rendu du contenu de l'onglet "Accueil"
        function renderAccueilTab() {
            document.getElementById('tabContent').innerHTML = `
                <div class="flex flex-col items-center justify-center p-4">
                    <h2 class="text-3xl font-semibold mb-6 text-center text-red-400">Bienvenue à Defqon 1 !</h2>
                    
                    <div class="mb-6 mx-auto">
                        <span id="onlineUsersCount" class="px-3 py-1 rounded-full bg-red-500 text-white text-sm font-semibold">
                            En ligne: 0
                        </span>
                    </div>

                    <!-- Compte à rebours du festival -->
                    <div id="countdownDisplay" class="countdown-box mx-auto">
                        <div class="countdown-text">Chargement...</div>
                        <div class="countdown-label"></div>
                    </div>
                </div>
            `;
            updateOnlineUsersCountDisplay();
            startCountdown();
        }

        // Rendu du contenu de l'onglet "Se retrouver" (sans la carte)
        function renderSeRetrouverTab() {
            document.getElementById('tabContent').innerHTML = `
                <div>
                    <h2 class="text-3xl font-semibold mb-6 text-center text-red-400">Où nous retrouver ?</h2>
                    
                    <div class="flex flex-col sm:flex-row gap-3 mt-6">
                        <input
                            type="text"
                            id="locationMessageInput"
                            placeholder="Partagez un message de localisation (facultatif)"
                            class="input-field flex-grow"
                        />
                        <button onclick="sendLocationMessageEvent()" class="btn-primary">
                            Envoyer message
                        </button>
                    </div>
                    <div id="sharedLocationsList" class="scrollable-content mt-4">
                        <!-- Les messages de localisation textuels seront injectés ici -->
                    </div>
                </div>
            `;
            updateLocationMessagesDisplay(); // Mettre à jour l'affichage des messages textuels
        }

        // Mettre à jour l'affichage des messages de localisation (texte)
        window.updateLocationMessagesDisplay = function() { 
            const listElement = document.getElementById('sharedLocationsList');
            if (!listElement) return;

            if (locationMessages.length === 0) {
                listElement.innerHTML = `<p class="text-center text-gray-400 italic">Aucun message de localisation pour l'instant. Partagez le vôtre !</p>`;
            } else {
                listElement.innerHTML = locationMessages.map(loc => {
                    const profile = userProfiles[loc.userId];
                    const senderName = profile && profile.firstName ? escapeHTML(profile.firstName) : (loc.userId ? loc.userId.substring(0, 8) + '...' : 'Inconnu');
                    return `
                    <div class="card flex items-center justify-between">
                        <div>
                            <p class="text-lg font-medium text-white">${escapeHTML(loc.message)}</p>
                            <p class="text-sm text-gray-400">
                                Par <span class="font-mono text-gray-300">${senderName}</span>
                                ${' à '}
                                ${loc.timestamp ? new Date(loc.timestamp).toLocaleTimeString('fr-FR') : 'N/A'}
                            </p>
                        </div>
                    </div>
                `;
                }).join('');
            }
        }

        // Rendu du contenu de l'onglet "Objectifs"
        function renderObjectifsTab() {
            document.getElementById('tabContent').innerHTML = `
                <div>
                    <h2 class="text-3xl font-semibold mb-6 text-center text-red-400">Objectifs du Festival</h2>
                    <div id="userGaugesContainer" class="flex justify-around items-end mb-8 flex-wrap gap-6">
                        <!-- Les jauges individuelles seront insérées ici par updateChallengeGauges() -->
                    </div>
                    <div class="flex flex-col sm:flex-row gap-3 mb-6">
                        <input
                            type="text"
                            id="newChallengeInput"
                            placeholder="Ajouter un nouvel objectif..."
                            class="input-field flex-grow"
                        />
                        <button onclick="addChallengeEvent()" class="btn-primary">
                            Ajouter
                        </button>
                    </div>
                    <div id="challengesList" class="scrollable-content">
                        <!-- Les objectifs seront injectés ici -->
                    </div>
                </div>
            `;
            updateChallengesDisplay();
            updateChallengeGauges();
        }

        // Mettre à jour l'affichage des défis (maintenant objectifs)
        function updateChallengesDisplay() {
            const listElement = document.getElementById('challengesList');
            if (!listElement) return;

            if (challenges.length === 0) {
                listElement.innerHTML = `<p class="text-center text-gray-400 italic">Aucun objectif ajouté pour l'instant.</p>`;
            } else {
                listElement.innerHTML = challenges.map(challenge => {
                    const completedByName = challenge.completedBy && userProfiles[challenge.completedBy] ? escapeHTML(userProfiles[challenge.completedBy].firstName) : 'Inconnu';
                    return `
                    <div class="card flex items-center justify-between">
                        <label class="flex items-center cursor-pointer flex-grow">
                            <input
                                type="checkbox"
                                ${challenge.completed ? 'checked' : ''}
                                onchange="toggleChallengeCompletionEvent('${challenge.id}', this.checked)"
                                class="form-checkbox h-6 w-6 text-red-600 rounded mr-3 bg-gray-700 border-gray-600 checked:bg-red-600 focus:ring-red-500"
                            />
                            <span class="text-lg ${challenge.completed ? 'line-through text-gray-500' : 'text-white'}">
                                ${escapeHTML(challenge.text)}
                            </span>
                        </label>
                        ${challenge.completed ? `<span class="text-sm text-green-400 ml-2">Complété par ${completedByName}</span>` : ''}
                    </div>
                `;
                }).join('');
            }
        }

        // --- Fonctions de mise à jour des jauges de défis (maintenant objectifs) ---
        function updateChallengeGauges() {
            const gaugesContainer = document.getElementById('userGaugesContainer');
            if (!gaugesContainer) return;

            // Filtrer les profils pour n'afficher que ceux qui ont un prénom
            const identifiableUsers = Object.values(userProfiles).filter(p => p.firstName);

            if (identifiableUsers.length === 0) {
                gaugesContainer.innerHTML = `<p class="text-center text-gray-400 italic">Connectez-vous pour voir la progression des objectifs des joueurs !</p>`;
                return;
            }

            gaugesContainer.innerHTML = ''; // Effacer les jauges précédentes

            const usersToDisplay = identifiableUsers.sort((a, b) => {
                // Tri pour que l'utilisateur actuel apparaisse en premier, puis les autres par prénom
                if (a.userId === currentUserId) return -1;
                if (b.userId === currentUserId) return 1;
                return a.firstName.localeCompare(b.firstName);
            }).slice(0, 2); // Limiter à 2 utilisateurs pour les jauges

            // For circular gauges
            const radius = 45; // Rayon du cercle
            const circumference = 2 * Math.PI * radius; // Circonférence du cercle


            usersToDisplay.forEach(profile => {
                const userIdToDisplay = profile.userId;
                const userCompletedChallenges = challenges.filter(c => c.completedBy === userIdToDisplay).length;
                const totalChallengesExisting = challenges.length;
                // Le pourcentage est basé sur les défis complétés par ce joueur par rapport au total des défis existants.
                const completionPercentage = totalChallengesExisting > 0 ? (userCompletedChallenges / totalChallengesExisting) * 100 : 0; // 0.0 to 100.0

                const userName = escapeHTML(profile.firstName);

                // Calcul pour le cercle
                const strokeDashoffset = circumference - (completionPercentage / 100) * circumference;

                const gaugeHtml = `
                    <div class="gauge-item-wrapper">
                        <svg class="gauge-svg" viewBox="0 0 100 100">
                            <circle cx="50" cy="50" r="${radius}" class="gauge-bg"></circle>
                            <circle cx="50" cy="50" r="${radius}" class="gauge-progress"
                                style="stroke-dasharray: ${circumference}; stroke-dashoffset: ${strokeDashoffset};"></circle>
                        </svg>
                        <div class="gauge-text-overlay">${userCompletedChallenges}</div>
                        <div class="gauge-label-overlay">${userName}</div>
                    </div>
                `;
                gaugesContainer.innerHTML += gaugeHtml;
            });
        }

        // Rendu du contenu de l'onglet "Tchat"
        function renderTchatTab() {
            document.getElementById('tabContent').innerHTML = `
                <div>
                    <h2 class="text-3xl font-semibold mb-6 text-center text-red-400">Tchat Global</h2>
                    <div id="chatMessagesContainer" class="scrollable-content h-96 bg-gray-800 rounded-lg p-4 mb-4 flex flex-col-reverse">
                        <!-- Les messages de chat seront injectés ici (en ordre inverse pour le défilement automatique) -->
                    </div>
                    <div class="flex flex-col sm:flex-row gap-3">
                        <input
                            type="text"
                            id="chatMessageInput"
                            placeholder="Écrivez votre message..."
                            class="input-field flex-grow"
                        />
                        <button onclick="sendChatMessage()" class="btn-primary">
                            Envoyer
                        </button>
                    </div>
                    ${!hasUserProfile ? `<p class="text-center text-red-400 mt-4">Veuillez vous enregistrer (onglet S'enregistrer) pour pouvoir envoyer des messages.</p>` : ''}
                </div>
            `;
            updateChatDisplay(); // Mettre à jour l'affichage du chat après le rendu de l'onglet
            // Faire défiler vers le bas après le rendu initial
            const chatMessagesContainer = document.getElementById('chatMessagesContainer');
            if (chatMessagesContainer) {
                chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
            }
        }

        // Mettre à jour l'affichage des messages de chat
        function updateChatDisplay() {
            const chatMessagesContainer = document.getElementById('chatMessagesContainer');
            if (!chatMessagesContainer) return;

            // Créer les messages en ordre normal, puis inverser pour flex-direction: column-reverse
            const messagesHtml = chatMessages.map(msg => {
                const profile = userProfiles[msg.userId];
                const senderName = profile && profile.firstName ? escapeHTML(profile.firstName) : (msg.userId ? msg.userId.substring(0, 8) + '...' : 'Inconnu');
                const isCurrentUser = msg.userId === currentUserId;
                const messageClass = isCurrentUser ? 'bg-red-700 self-end' : 'bg-gray-700 self-start';
                const textColorClass = isCurrentUser ? 'text-white' : 'text-gray-200';

                return `
                    <div class="flex flex-col mb-2 p-2 rounded-lg max-w-[80%] ${messageClass}">
                        <span class="font-bold text-sm ${textColorClass}">${senderName}</span>
                        <p class="text-base ${textColorClass}">${escapeHTML(msg.message)}</p>
                        <span class="text-xs text-gray-300 self-end mt-1">${new Date(msg.timestamp).toLocaleTimeString('fr-FR')}</span>
                    </div>
                `;
            }).join('');

            chatMessagesContainer.innerHTML = messagesHtml;

            // Défiler automatiquement vers le bas si l'utilisateur est déjà tout en bas
            // ou si c'est son propre message
            const shouldScroll = chatMessagesContainer.scrollTop + chatMessagesContainer.clientHeight >= chatMessagesContainer.scrollHeight - 50; // Tolérance de 50px
            if (shouldScroll) {
                chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
            }
        }


        // Rendu du contenu de l'onglet "S'enregistrer / Mon Profil"
        function renderProfileTab() {
            const tabContentElement = document.getElementById('tabContent');
            if (!tabContentElement) return;

            if (hasUserProfile && userProfiles[currentUserId]) {
                const userProfile = userProfiles[currentUserId];
                tabContentElement.innerHTML = `
                    <div>
                        <h2 class="text-3xl font-semibold mb-6 text-center text-red-400">Mon Profil</h2>
                        <p class="text-center text-gray-400 mb-4">
                            Gérez vos informations de profil.
                        </p>
                        <div class="flex flex-col gap-4 mb-6 p-4 bg-gray-800 rounded-lg shadow-md">
                            <p class="text-lg"><span class="font-bold">Prénom:</span> ${escapeHTML(userProfile.firstName || 'Non renseigné')}</p>
                            <p class="text-lg"><span class="font-bold">Téléphone:</span> ${escapeHTML(window.formatPhoneNumber({ value: userProfile.phoneNumber || '' })) || 'Non renseigné'}</p>
                            <div class="text-center text-gray-500 mt-2 text-sm">
                                Votre ID unique: <span class="font-mono bg-gray-700 rounded px-2 py-1">${currentUserId ? currentUserId : 'Chargement...'}</span>
                            </div>
                        </div>
                        <div class="flex flex-col gap-4 mt-6">
                            <button onclick="setActiveTab('accueil')" class="btn-primary bg-gray-600 hover:bg-gray-700">
                                Retour à l'Accueil
                            </button>
                            <button onclick="logout()" class="btn-primary bg-red-800 hover:bg-red-900">
                                Se déconnecter
                            </button>
                        </div>
                    </div>
                `;
            } else {
                tabContentElement.innerHTML = `
                    <div>
                        <h2 class="text-3xl font-semibold mb-6 text-center text-red-400">S'enregistrer</h2>
                        <p class="text-center text-gray-400 mb-4">
                            Enregistrez votre prénom et numéro de téléphone pour pouvoir utiliser toutes les fonctionnalités (chat, etc.).
                        </p>
                        <div class="flex flex-col gap-4 mb-6">
                            <input
                                type="text"
                                id="firstNameInput"
                                placeholder="Votre prénom"
                                class="input-field"
                            />
                            <input
                                type="tel"
                                id="phoneNumberInput"
                                placeholder="Votre numéro de téléphone (10 chiffres)"
                                class="input-field"
                                oninput="formatPhoneNumber(this)"
                                maxlength="14" />
                            <button onclick="saveProfile()" class="btn-primary">
                                Enregistrer le profil
                            </button>
                        </div>
                        <div class="text-center text-gray-500 mt-6 text-sm">
                            Votre ID unique: <span class="font-mono bg-gray-700 rounded px-2 py-1">${currentUserId ? currentUserId : 'Chargement...'}</span>
                        </div>
                    </div>
                `;
                // Pré-remplir les champs si le profil existe déjà mais n'est pas "complet"
                if (currentUserId && userProfiles[currentUserId]) {
                    document.getElementById('firstNameInput').value = userProfiles[currentUserId].firstName || '';
                    const rawPhoneNumber = userProfiles[currentUserId].phoneNumber || '';
                    document.getElementById('phoneNumberInput').value = window.formatPhoneNumber({ value: rawPhoneNumber });
                }
            }
        }

        // Rendu du contenu de l'onglet "NoisyNeighbors"
        function renderNoisyNeighborsTab() {
            document.getElementById('tabContent').innerHTML = `
                <div class="flex flex-col items-center justify-center p-4">
                    <h2 class="text-3xl font-semibold mb-6 text-center text-red-400">NoisyNeighbors</h2>
                    <p class="text-center text-gray-400 mb-6">Partagez notre musique et connectez-vous !</p>

                    <div class="flex flex-col sm:flex-row gap-4 mb-8">
                        <button onclick="generateAndDisplayQRCode('instagram')" class="btn-primary bg-pink-600 hover:bg-pink-700">
                            Partager Instagram
                        </button>
                        <button onclick="generateAndDisplayQRCode('soundcloud')" class="btn-primary bg-orange-600 hover:bg-orange-700">
                            Partager SoundCloud
                        </button>
                    </div>

                    <div id="qrCodeContainer" class="flex flex-col items-center justify-center p-4 bg-gray-800 rounded-lg shadow-lg" style="min-height: 250px; min-width: 250px;">
                        <p class="text-gray-400">Cliquez sur un bouton pour générer le QR Code.</p>
                    </div>

                    <button onclick="setActiveTab('accueil')" class="btn-primary mt-8">
                        Retour à l'Accueil
                    </button>
                </div>
            `;
        }

        // Fonction pour générer et afficher le QR Code
        window.generateAndDisplayQRCode = function(platform) {
            const qrCodeContainer = document.getElementById('qrCodeContainer');
            qrCodeContainer.innerHTML = ''; // Effacer le contenu précédent (texte ou QR Code)

            let urlToEncode = '';
            let label = '';
            if (platform === 'instagram') {
                urlToEncode = INSTAGRAM_URL;
                label = 'Instagram';
            } else if (platform === 'soundcloud') {
                urlToEncode = SOUNDCLOUD_URL;
                label = 'SoundCloud';
            }

            if (urlToEncode) {
                const canvas = document.createElement('canvas');
                canvas.id = 'qrCodeCanvas';
                // La taille du canvas doit être suffisamment grande pour le QR code
                canvas.width = 200; 
                canvas.height = 200; 

                qrCodeContainer.appendChild(canvas);

                // Crée le QR Code en utilisant la bibliothèque QRious
                new QRious({
                    element: canvas,
                    value: urlToEncode,
                    size: 200, // Taille réelle du QR code rendu sur le canvas
                    padding: 20,
                    foreground: '#dc2626', // Couleur rouge pour le QR code
                    background: '#000000', // Fond noir
                });

                // Ajoute une étiquette sous le QR code
                const qrLabel = document.createElement('p');
                qrLabel.className = 'text-gray-400 mt-2';
                qrLabel.textContent = `QR Code pour ${label}`;
                qrCodeContainer.appendChild(qrLabel);

            } else {
                qrCodeContainer.innerHTML = '<p class="text-gray-400">URL non trouvée pour le QR Code.</p>';
            }
        };

        // Mettre à jour l'affichage du compteur d'utilisateurs en ligne
        function updateOnlineUsersCountDisplay() {
            const displayElement = document.getElementById('onlineUsersCount');
            if (displayElement) {
                displayElement.textContent = `En ligne: ${onlineUsersCount}`;
            }
        }

        // --- Countdown Functions ---
        function startCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval); // Ensure there's only one active interval
            }
            countdownInterval = setInterval(updateCountdown, 1000); // Update every second
            updateCountdown(); // Call once immediately to avoid initial delay
        }

        function updateCountdown() {
            const now = new Date().getTime();
            const countdownText = document.querySelector('#countdownDisplay .countdown-text');
            const countdownLabel = document.querySelector('#countdownDisplay .countdown-label');


            if (!countdownText || !countdownLabel) {
                // If elements are not found, clear the interval to prevent errors
                clearInterval(countdownInterval); 
                countdownInterval = null; // Reset interval ID
                return;
            }

            if (now < DEFQON_START_DATE.getTime()) {
                // Before the festival starts: Display countdown
                const distance = DEFQON_START_DATE.getTime() - now;

                const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);

                countdownText.innerHTML = `${days}j ${hours}h ${minutes}m ${seconds}s`;
                // Clear the label
                countdownLabel.textContent = '';
                countdownLabel.classList.remove('visible'); // Hide the label


            } else if (now >= DEFQON_START_DATE.getTime() && now <= DEFQON_END_DATE.getTime()) {
                // During the festival: Display Day 1, Day 2, etc.
                const oneDay = 1000 * 60 * 60 * 24;
                const diffDays = Math.floor((now - DEFQON_START_DATE.getTime()) / oneDay);
                let festivalDay = diffDays + 1; // Day 1 = diff 0, Day 2 = diff 1, etc.

                if (festivalDay > 4) { // Ensure not to exceed Day 4 if the festival is over
                    countdownText.innerHTML = "Terminé !";
                    countdownLabel.textContent = "Le festival Defqon 1 est terminé pour cette année !";
                    countdownLabel.classList.add('visible'); // Show the label
                    countdownLabel.classList.add('font-bold'); // Make the label bold
                    clearInterval(countdownInterval);
                    countdownInterval = null; // Reset interval ID
                } else {
                    countdownText.innerHTML = `Jour ${festivalDay}`;
                    countdownLabel.textContent = `Profitez de la Defqon 1 !`;
                    countdownLabel.classList.add('visible'); // Show the label
                    countdownLabel.classList.add('font-bold'); // Make the label bold
                }
            } else {
                // After the festival ends
                countdownText.innerHTML = "Terminé !";
                countdownLabel.textContent = "Le festival Defqon 1 est terminé pour cette année !";
                countdownLabel.classList.add('visible'); // Show the label
                countdownLabel.classList.add('font-bold'); // Make the label bold
                clearInterval(countdownInterval); // Stop the countdown
                countdownInterval = null; // Reset interval ID
            }
        }

        // Function to activate a tab
        // Expose the function to the global scope
        window.setActiveTab = function(tabName) {
            // Clear any active countdown interval when switching tabs
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null; // Reset interval ID
            }

            // Mettre à jour les classes des boutons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
                button.classList.remove('scale-105');
            });
            // Gérer séparément les boutons "Se connecter/Mon Profil" et "NoisyNeighbors"
            const tabConnectButton = document.getElementById('tabConnect');
            if (tabConnectButton) {
                tabConnectButton.classList.remove('active');
                tabConnectButton.classList.remove('scale-105');
            }
            const tabNoisyNeighborsButton = document.getElementById('tabNoisyNeighbors');
            if (tabNoisyNeighborsButton) {
                tabNoisyNeighborsButton.classList.remove('active');
                tabNoisyNeighborsButton.classList.remove('scale-105');
            }


            // Assurez-vous que l'élément existe avant de tenter d'ajouter la classe 'active'
            const targetButton = document.getElementById('tab' + tabName.charAt(0).toUpperCase() + tabName.slice(1));
            if (targetButton) {
                targetButton.classList.add('active');
            } else if (tabName === 'connect' && tabConnectButton) {
                tabConnectButton.classList.add('active');
            } else if (tabName === 'noisyNeighbors' && tabNoisyNeighborsButton) {
                tabNoisyNeighborsButton.classList.add('active');
            }


            // Afficher le contenu de l'onglet
            switch (tabName) {
                case 'accueil':
                    renderAccueilTab();
                    break;
                case 'seRetrouver':
                    renderSeRetrouverTab();
                    break;
                case 'objectifs':
                    renderObjectifsTab();
                    break;
                case 'tchat':
                    renderTchatTab(); // Appel à la fonction maintenant définie
                    break;
                case 'connect':
                    renderProfileTab(); // Appel à la nouvelle fonction pour la gestion du profil/enregistrement
                    break;
                case 'noisyNeighbors':
                    renderNoisyNeighborsTab();
                    break;
                default:
                    renderAccueilTab();
            }
        }

        // --- APPLICATION INITIALIZATION (après chargement du DOM) ---
        window.addEventListener('beforeunload', () => {
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
        });
    </script>
</body>
</html>
